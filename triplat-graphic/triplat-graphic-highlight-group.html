<!--
@license
IBM Confidential - OCO Source Materials - (C) COPYRIGHT IBM CORP. 2015-2016 - The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
-->
<!--
A plugin to enable a highlight group on a graphic. It will be used as an inner element of triplat-graphic.
In the example below, we're creating a highlight group
against the list of spaces called "spacesForGrouping". The spaces will be grouped by their "occupancy" status and
will be colored by their "color" property. Also, a mask opacity = 0.1 (10%) is set. The mask will affect every
space other than the ones under "spacesForGrouping". 

In order to define settings for each group, we will make use of "highlight spaces". Each highlight-class defines
a value that the group-by property can assume as well as a CSS class that can be applied to that group. In the example
below, there is a highlight class defined with value="occupied". It means that every space in the
"spacesForGrouping" list that has "occupancy" = "occupied" will get the CSS class number 1 applied.

    <triplat-graphic-highlight-group spaces="{{spacesForGrouping}}" group-by="occupancy" 
        color-by="color" mask-opacity="0.1">
        
        <triplat-graphic-highlight-class value="occupied" class-number="1">
        </triplat-graphic-highlight-class>

        <triplat-graphic-highlight-class value="partially occupied" class-number="2">
        </triplat-graphic-highlight-class>

        <triplat-graphic-highlight-class value="vacant" class-number="3">
        </triplat-graphic-highlight-class>

    </triplat-graphic-highlight-group>


### Styling

Style the highlight class using the --triplat-graphic-highlight-group- mixin on the triplat-graphic 
element. The number of the variable corresponds to the property classNumber of the 
triplat-graphic-highlight-class.  The classNumber must be between 1 and 5 inclusive.

Example:
    
    triplat-graphic { 
         --triplat-graphic-highlight-group-2: {
              fill: #8CD211;
              fill-opacity: 1;
         };
    }

Custom property | Description | Default
----------------|-------------|----------
`--triplat-graphic-highlight-group-1` | Mixin for groups highlighted with class-number="1" | `{}`
`--triplat-graphic-highlight-group-2` | Mixin for groups highlighted with class-number="2" | `{}`
`--triplat-graphic-highlight-group-3` | Mixin for groups highlighted with class-number="3" | `{}`
`--triplat-graphic-highlight-group-4` | Mixin for groups highlighted with class-number="4" | `{}`
`--triplat-graphic-highlight-group-5` | Mixin for groups highlighted with class-number="5" | `{}`

-->
<dom-module id="triplat-graphic-highlight-group">
	<template>
    </template>
</dom-module>
<script>
    TriplatHighlightGroupLayers = {};
    TriplatHighlightGroupLayers.INTERACTIVE = "INTERACTIVE";
    TriplatHighlightGroupLayers.ATTACHED = "ATTACHED";

	Polymer({

		is: "triplat-graphic-highlight-group",

		properties: {

			/**
			 * The graphic on which the shapes will be highlighted. 
			 * Usually, this is automatically set by triplat-graphic.
			 */
			graphic: Object,

			/**
			 * An object containing the shapes to be grouped and highlighted.
			 */
			spaces: {
				type: Object,
				notify: false,
				readOnly: false,
			},
            
            /**
			 * The property of a space on which the groups will be created.
			 */
            groupBy: String,
            
             /**
			 * The property of a space that will provide the color value for
             * each space.
			 */
            colorBy: String,
            
            /**
			 * The opacity value that will be applied to a mask over every
             * other space other than the ones under the grouping.
             * A higher value will make the spaces more visible.
			 */
            maskOpacity: {
                type: Number,
                value: 0.9
            },
            
            /**
             * Sets an array of spaces to be highlighted by this plugin. This property is supposed to receive the array of 
             * spaces generated by the triplat-graphic-legend component.
             * The spaces in this array are already grouped and filtered by the legend component.
             */
            legendSpaces: {
                type: Array,
                notify: false,
                readOnly: false,
            },

            /**
             * Sets the spaces layer that will be highlighted by this plugin.
             * There are two options:
             * - INTERACTIVE: highlights the interactive (top) layer of the graphic.
             * - ATTACHED: highlights the attached layer of the graphic. If this option is used, the 
             * <b>maskOpacity</b> will be applied to the whole floorplan.
             */
            highlightLayer: {
                type: String,
                value: TriplatHighlightGroupLayers.INTERACTIVE
            },

            _svgLoaded: {
                type: Boolean,
				readOnly: true,
                value: false
            },
            
            _groups: {
                type: Object,
                value: {}
            },

            _rectElementAppended: {
                type: Boolean,
                value: false
            }
		},

		observers: [
            "_initializeGraphic(graphic)",
			"_changeSpaces(spaces.*, _svgLoaded)",
            "_setMaskElement(_svgLoaded)",
            "_changeLegendSpaces(legendSpaces.*, _svgLoaded)"
		],
        
        _initializeGraphic: function(graphic) {
            this.listen(graphic, "svg-loaded", "_handleSvgLoadedChanged");
		},
        
        ready: function(){
            this._observer = Polymer.dom(this).observeNodes(function(info) {
                var groups = this.queryAllEffectiveChildren("triplat-graphic-highlight-class");
                groups.forEach(function(group){
                    this._groups[group.value.toLowerCase()] = group.classNumber;       
                }, this);
            });
        },

        // Refreshes the mask element.
        refreshMaskElement: function() {
            this._setMaskElement(this._svgLoaded);
        },

        // Check if an element is visible.
        _isVisible: function(el) {
            return !!( el.offsetWidth || el.offsetHeight || el.getClientRects().length );
        },
        
        _setMaskElement: function(svgLoaded) {
            var isGraphicVisisble = (this.graphic) ? this._isVisible(this.graphic) : false;

            if (!svgLoaded || !isGraphicVisisble || this._rectElementAppended) {
                return;   
            }

            var svgElement = this.graphic.svgElement;
            var extents = svgElement.getBBox();
            var maskGroup = Polymer.dom(svgElement).querySelector("#_triMaskLayer");
            var rectElement = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            rectElement.setAttribute("x", extents.x);
            rectElement.setAttribute("y", extents.y);
            rectElement.setAttribute("width", extents.width);
            rectElement.setAttribute("height", extents.height);
            rectElement.setAttribute("fill", "rgb(255,255,255)");
            rectElement.setAttribute("fill-opacity", 1 - this.maskOpacity);
            Polymer.dom(maskGroup).appendChild(rectElement);
            this._rectElementAppended = true;
        },

		_changeSpaces: function(change, svgLoaded){
			if (!svgLoaded) {
				return;
			}
            
			if(change.path == "spaces"){
                this._clearAllAttachedClasses();
                if(change.value){
                    change.value.forEach(function(space){
                        var groupValue = this._getGroupValue(space[this.groupBy]);
                        var classNumber = this._groups[groupValue];
                        this._addClass(space._id, classNumber, space[this.colorBy]);
                    }, this);
                }
                this._forceMicrosoftStyleUpdate();
			}

			if(change.path == "spaces.splices"){
				var indexSplice = change.value.indexSplices[0];
				indexSplice.removed.forEach(function(removed) {
                    var groupValue = this._getGroupValue(removed[this.groupBy]);
                    var classNumber = this._groups[groupValue];
					this._removeClass(removed._id, classNumber);
				}, this);
				for (var i = 0; i < indexSplice.addedCount; i++) {
                    var added = indexSplice.object[indexSplice.index + i];
                    var groupValue = this._getGroupValue(added[this.groupBy]);
                    var classNumber = this._groups[groupValue];
				    this._addClass(added._id, classNumber, added[this.colorBy]);
				}
                
                this._forceMicrosoftStyleUpdate();
			}
		},
        
        _forceMicrosoftStyleUpdate: function() {
            /*
             * In IE and Edge sometimes the style is not applied, accessing the offsetWidth forces 
             * the browser to update the styles.
             */
            this.graphic.getSvgContainer().offsetWidth;
        },
        
        _clearAllAttachedClasses: function(){
            for(var i=1; i<=5; i++){
                this.graphic.clearAllAttachedClasses(this._getClassName(i));    
            }    
        },
        
        _getGroupValue: function(groupValue){
            return groupValue.value ? groupValue.value.toLowerCase() : groupValue.toLowerCase();        
        },

		_addClass: function(id, classNumber, defaultColor) {
            var interactiveLayer = this.highlightLayer == TriplatHighlightGroupLayers.INTERACTIVE;
            this.graphic.addAttachedClassHGroup(id, this._getClassName(classNumber), 
                    defaultColor, interactiveLayer);
		},

		_removeClass: function(id, classNumber) {
			this.graphic.removeAttachedClass(id, this._getClassName(classNumber));
		},

		_getClassName: function(classNumber) {
			return "tri-highlight-group-" + classNumber;
		},
        
        _handleSvgLoadedChanged: function(e){
            this._set_svgLoaded(e.detail);
        },

        _changeLegendSpaces: function(change, svgLoaded){
            if (!svgLoaded) {
                return;
            }

            if(this.spaces && this.spaces.length > 0) {
                console.log("The 'legend-spaces' property and the 'spaces' property cannot be used together.");
                return;
            }
            
            if(change.path == "legendSpaces"){
                this._clearAllLegendSpaces();
                if(change.value){
                    change.value.forEach(function(legendSpace) {
                        this._highlightLegendSpace(legendSpace);
                    }, this);
                }
                this._forceMicrosoftStyleUpdate();
            }

            if(change.path == "legendSpaces.splices"){
                var indexSplice = change.value.indexSplices[0];
                indexSplice.removed.forEach(function(legendSpace) {
                    this._removeLegendSpace(legendSpace.id, legendSpace.classNumber);
                }, this);
                for (var i = 0; i < indexSplice.addedCount; i++) {
                    var legendSpace = indexSplice.object[indexSplice.index + i]
                    this._highlightLegendSpace(legendSpace);
                }
                
                this._forceMicrosoftStyleUpdate();
            }
        },

        _getSpaceElement: function(id) {
            if (this.highlightLayer == TriplatHighlightGroupLayers.INTERACTIVE) {           
                return this.graphic.interactiveElementsByRecordId[id];
            } else {
                return this.graphic.attachedElementsByRecordId[id];
            }
        },

        _highlightLegendSpace: function(legendSpace) {
            var space = this._getSpaceElement(legendSpace.id);
            if (space) {
                var color = this._getSpaceColor(space, legendSpace);
                this._addClass(legendSpace.id, legendSpace.classNumber, color);
                space.style["fill-opacity"] = legendSpace.fillOpacity;
            }
        },

        _getSpaceColor: function(space, legendSpace) {
            var color = "";
            if(legendSpace.color && legendSpace.color.values) {
                if (legendSpace.color.values.length == 1) {
                    color = legendSpace.color.values[0];
                } else {
                    color = this._createLinearGradient(space, legendSpace);
                }
            }
            return color;
        },

        _createLinearGradient: function(space, legendSpace) {
            var color = "tri-gradient-" + legendSpace.id;
            var linearGradient = document.createElementNS("http://www.w3.org/2000/svg", "linearGradient");
            linearGradient.setAttribute("id", color);
            linearGradient.setAttribute("x1", "0%");
            linearGradient.setAttribute("y1", "0%");

            if(legendSpace.color.direction && legendSpace.color.direction === "horizontal") {
                linearGradient.setAttribute("x2", "100%");
                linearGradient.setAttribute("y2", "0%");
            } else {
                linearGradient.setAttribute("x2", "0%");
                linearGradient.setAttribute("y2", "100%");
            }

            var baseOffset = 100/(legendSpace.color.values.length);
            for (var i = 0; i < legendSpace.color.values.length; i++) {
                var stop = document.createElementNS("http://www.w3.org/2000/svg", "stop");
                stop.setAttribute("offset", Math.trunc(baseOffset*i)+"%");
                stop.setAttribute("stop-color", legendSpace.color.values[i]);
                linearGradient.appendChild(stop);

                stop = document.createElementNS("http://www.w3.org/2000/svg", "stop");
                stop.setAttribute("offset", Math.trunc(baseOffset*(i+1))+"%");
                stop.setAttribute("stop-color", legendSpace.color.values[i]);
                linearGradient.appendChild(stop);
            }

            Polymer.dom(this.graphic.svgElement).appendChild(linearGradient);
            space.color = linearGradient;
            return "url(#" + color + ")";
        },

        _clearAllLegendSpaces: function() {
            for(var i=1; i<=5; i++){
                Polymer.dom(this.graphic.svgElement).querySelectorAll("." + this._getClassName(i)).forEach(function(space) {
                    this._removeLegendSpace(space.getAttribute("tri-record-id"), i);
                }, this);     
            }             
        },

        _removeLegendSpace: function(id, classNumber) {
            this._removeClass(id, classNumber);
            var space = this._getSpaceElement(id);
             if (space.color) {
                Polymer.dom(this.graphic.svgElement).removeChild(space.color);
                space.color = null;
            }
            space.style["fill-opacity"] = "";
            space.style.fill = "";
        }

	});
    
    HighlightClass = Polymer({

        is: "triplat-graphic-highlight-class",
        
        properties: {
            value: String,
            classNumber: Number
        }
    });

</script>